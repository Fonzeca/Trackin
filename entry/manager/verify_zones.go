package manager

import (
	"math"
	"strconv"
	"strings"

	"github.com/Fonzeca/Trackin/db/model"
	"github.com/Fonzeca/Trackin/entry/json"
	"github.com/Fonzeca/Trackin/server/manager"
)

type Point struct {
	lat float64
	lng float64
}

type GeofenceDetector struct {
	last_logs map[string]Point
	manager   manager.ZonasManager
}

func NewGeofenceDetector() *GeofenceDetector {
	zm := manager.NewZonasManager()
	return &GeofenceDetector{
		manager:   *zm,
		last_logs: make(map[string]Point),
	}
}

func (d *GeofenceDetector) ProcessData(data json.SimplyData) error {

	print("procesando " + data.Imei)

	imei := data.Imei

	oldVehiclePoint, ok := d.last_logs[imei]

	var currentVehiclePoint Point = Point{lat: data.Latitude, lng: data.Longitude}

	if !ok {
		d.last_logs[imei] = currentVehiclePoint
		return nil
	}

	zonesConfig, zonesRequestErr := d.manager.GetZoneConfigByImei(imei)

	if zonesRequestErr != nil {
		return zonesRequestErr
	}

	if len(zonesConfig) <= 0 {
		//El vehiculo no está asociado a ninguna zona, por lo tanto no hacemos nada
		return nil
	}

	for _, zoneConfig := range zonesConfig {

		//Si el vehíuclo no tiene que avisar nada en una zona, salteamos la zona
		if !zoneConfig.AvisarEntrada || !zoneConfig.AvisarSalida {
			continue
		}

		//Obtenemos los puntos del poligono de la zona, porque estan almacenados como un string
		var splittedPoints []string = strings.Split(zoneConfig.Puntos, "; ")
		var polygon []Point

		for _, point := range splittedPoints {
			var splittedPoint []string = strings.Split(point, ",")
			lat, _ := strconv.ParseFloat(splittedPoint[0], 32)
			lng, _ := strconv.ParseFloat(splittedPoint[1], 32)
			polygon = append(polygon, Point{lat: lat, lng: lng})
		}

		var isCurrentVehiclePointInZone bool = isPointInPolygon(currentVehiclePoint, polygon)
		var isOldVehiclePointInZone bool = isPointInPolygon(oldVehiclePoint, polygon)

		if zoneConfig.AvisarEntrada {
			if isCurrentVehiclePointInZone && !isOldVehiclePointInZone {
				autoGenerated := model.AutoGenerated{
					Imei:      imei,
					ZoneName:  zoneConfig.Nombre,
					ZoneID:    int(zoneConfig.Id),
					EventType: "avisar_entrada",
				}
				print("Mandando a rabbit mq ")
				print(autoGenerated.Imei)
				print(autoGenerated.ZoneName)
				print(autoGenerated.ZoneID)
				print(autoGenerated.EventType)
			}
		}

		if zoneConfig.AvisarSalida {
			if !isCurrentVehiclePointInZone && isOldVehiclePointInZone {
				autoGenerated := model.AutoGenerated{
					Imei:      imei,
					ZoneName:  zoneConfig.Nombre,
					ZoneID:    int(zoneConfig.Id),
					EventType: "avisar_salida",
				}
				print("Mandando a rabbit mq ")
				print(autoGenerated.Imei)
				print(autoGenerated.ZoneName)
				print(autoGenerated.ZoneID)
				print(autoGenerated.EventType)
			}
		}

	}

	return nil
}

func isPointInPolygon(p Point, polygon []Point) bool {

	minX := polygon[0].lat
	maxX := polygon[0].lat
	minY := polygon[0].lng
	maxY := polygon[0].lng

	for _, point := range polygon {
		minX = math.Min(point.lat, minX)
		maxX = math.Max(point.lat, maxX)
		minY = math.Min(point.lng, minY)
		maxY = math.Max(point.lng, maxY)
	}

	if p.lat < minX || p.lat > maxX || p.lng < minY || p.lng > maxY {
		return false
	}

	var isInside bool = false

	j := len(polygon) - 1
	for i := 0; i < len(polygon); j = i + 1 {
		if (polygon[i].lng > p.lng) != (polygon[j].lng > p.lng) &&
			p.lat < (polygon[j].lat-polygon[i].lat)*(p.lng-polygon[i].lng)/(polygon[j].lng-polygon[i].lng)+polygon[i].lat {
			isInside = !isInside
		}
	}

	return isInside
}
